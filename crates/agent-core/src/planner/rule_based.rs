use crate::errors::AgentError;
use crate::model::AgentRequest;
use crate::plan::{
    AgentLocator, AgentPlan, AgentPlanMeta, AgentPlanStep, AgentScrollTarget, AgentTool,
    AgentToolKind, AgentValidation, AgentWaitCondition, WaitMode,
};
use crate::planner::{AgentPlanner, PlannerConfig, PlannerOutcome};
use once_cell::sync::Lazy;
use regex::Regex;
use serde_json::{json, Number as JsonNumber, Value};
use std::borrow::Cow;
use std::collections::HashMap;

/// Simple rule-based planner that turns user goals into structured steps.
#[derive(Debug, Clone)]
pub struct RuleBasedPlanner {
    config: PlannerConfig,
}

impl RuleBasedPlanner {
    pub fn new(config: PlannerConfig) -> Self {
        Self { config }
    }

    fn default_title(goal: &str) -> String {
        let trimmed = goal.trim();
        if trimmed.is_empty() {
            "Agent task".to_string()
        } else if trimmed.len() <= 72 {
            trimmed.to_string()
        } else {
            format!("{}â€¦", trimmed.chars().take(69).collect::<String>())
        }
    }
}

impl Default for RuleBasedPlanner {
    fn default() -> Self {
        Self {
            config: PlannerConfig::default(),
        }
    }
}

impl AgentPlanner for RuleBasedPlanner {
    fn draft_plan(&self, request: &AgentRequest) -> Result<PlannerOutcome, AgentError> {
        if request.goal.trim().is_empty() {
            return Err(AgentError::invalid_request("goal cannot be empty"));
        }

        let mut plan = AgentPlan::new(request.task_id.clone(), Self::default_title(&request.goal))
            .with_description(format!(
                "Generated by heuristics for goal: {}",
                request.goal.trim()
            ));

        let mut explanations: Vec<String> = Vec::new();
        let mut steps: Vec<AgentPlanStep> = Vec::new();

        if self.config.auto_navigate {
            if let Some(url) = extract_first_url(&request.goal) {
                let mut nav_step = AgentPlanStep::new(
                    step_id(steps.len()),
                    "Navigate to target page",
                    AgentTool {
                        kind: AgentToolKind::Navigate { url: url.clone() },
                        wait: WaitMode::Idle,
                        timeout_ms: None,
                    },
                )
                .with_detail(format!("Open the target site at {}", url));
                nav_step.validations.push(AgentValidation {
                    description: "Ensure navigation reached the intended URL".to_string(),
                    condition: AgentWaitCondition::UrlMatches(url.clone()),
                });
                explanations.push(format!("Detected URL in goal, added navigation to {}", url));
                steps.push(nav_step);
            }
        }

        let phrases = split_phrases(&request.goal);
        for phrase in phrases {
            if steps.len() >= self.config.max_steps {
                explanations.push(format!(
                    "Reached max step limit ({}), ignoring remaining instructions",
                    self.config.max_steps
                ));
                break;
            }

            if let Some(step) = phrase_to_step(&phrase, steps.len())? {
                explanations.push(format!("Mapped '{}' to {}", phrase.trim(), step.title));
                steps.push(step);
            }
        }

        if steps.is_empty() {
            let fallback = AgentPlanStep::new(
                step_id(0),
                "Review goal context",
                AgentTool {
                    kind: AgentToolKind::Custom {
                        name: "agent.note".to_string(),
                        payload: json!({
                            "message": "No executable actions inferred from goal",
                            "goal": request.goal,
                        }),
                    },
                    wait: WaitMode::None,
                    timeout_ms: None,
                },
            )
            .with_detail(
                "Collect additional details or hand off to human operator because no actionable steps were detected.",
            );
            explanations.push(
                "Fallback note created because no automation-friendly steps were found".to_string(),
            );
            steps.push(fallback);
        }

        for step in steps.into_iter() {
            plan.push_step(step);
        }

        plan.meta = AgentPlanMeta {
            rationale: explanations.clone(),
            risk_assessment: default_risks(request),
            vendor_context: vendor_context_snapshot(request),
        };

        Ok(PlannerOutcome { plan, explanations })
    }
}

fn step_id(index: usize) -> String {
    format!("step-{}", index + 1)
}

fn phrase_to_step(phrase: &str, index: usize) -> Result<Option<AgentPlanStep>, AgentError> {
    let normalized = phrase.trim();
    if normalized.is_empty() {
        return Ok(None);
    }

    let lowercase = normalized.to_lowercase();

    if let Some(seconds) = capture_wait_seconds(&lowercase) {
        let step = AgentPlanStep::new(
            step_id(index),
            "Wait for duration",
            AgentTool {
                kind: AgentToolKind::Wait {
                    condition: AgentWaitCondition::Duration(seconds * 1000),
                },
                wait: WaitMode::None,
                timeout_ms: Some(seconds * 1000 + 1000),
            },
        )
        .with_detail(format!(
            "Pause for {} seconds to allow the page to settle",
            seconds
        ));
        return Ok(Some(step));
    }

    if lowercase.starts_with("wait for") || lowercase.starts_with("wait until") {
        if let Some(label) = extract_first_quoted(normalized) {
            let locator = AgentLocator::Text {
                content: label.clone(),
                exact: false,
            };
            let mut step = AgentPlanStep::new(
                step_id(index),
                "Wait for element",
                AgentTool {
                    kind: AgentToolKind::Wait {
                        condition: AgentWaitCondition::ElementVisible(locator.clone()),
                    },
                    wait: WaitMode::None,
                    timeout_ms: None,
                },
            )
            .with_detail(format!(
                "Wait until element containing '{}' becomes visible",
                label
            ));
            step.validations.push(AgentValidation {
                description: format!("Element '{}' becomes visible", label),
                condition: AgentWaitCondition::ElementVisible(locator),
            });
            return Ok(Some(step));
        }
    }

    if lowercase.contains("click") {
        let locator = derive_click_locator(normalized).ok_or_else(|| {
            AgentError::unsupported(format!(
                "could not derive locator for instruction '{}'",
                phrase
            ))
        })?;
        let mut step = AgentPlanStep::new(
            step_id(index),
            "Click element",
            AgentTool {
                kind: AgentToolKind::Click {
                    locator: locator.clone(),
                },
                wait: WaitMode::DomReady,
                timeout_ms: None,
            },
        )
        .with_detail(format!(
            "Click element referenced by instruction '{}'.",
            normalized
        ));
        step.validations.push(AgentValidation {
            description: "Target element becomes hidden or navigates away".to_string(),
            condition: AgentWaitCondition::ElementHidden(locator.clone()),
        });
        return Ok(Some(step));
    }

    if lowercase.contains("enter")
        || lowercase.contains("type")
        || lowercase.contains("fill")
        || lowercase.contains("input")
    {
        if let Some(step) = derive_type_step(normalized, index)? {
            return Ok(Some(step));
        }
    }

    if lowercase.contains("select") {
        if let Some(step) = derive_select_step(normalized, index)? {
            return Ok(Some(step));
        }
    }

    if lowercase.contains("scroll") {
        if let Some(step) = derive_scroll_step(normalized, index)? {
            return Ok(Some(step));
        }
    }

    Ok(None)
}

fn derive_click_locator(phrase: &str) -> Option<AgentLocator> {
    if let Some(label) = extract_first_quoted(phrase) {
        return Some(AgentLocator::Text {
            content: label,
            exact: false,
        });
    }

    if phrase.to_lowercase().contains("submit") {
        return Some(AgentLocator::Text {
            content: "submit".to_string(),
            exact: false,
        });
    }

    if let Some(capture) = CLICK_WORD_REGEX.captures(phrase) {
        let word = capture.name("label")?.as_str().trim().to_string();
        if !word.is_empty() {
            return Some(AgentLocator::Text {
                content: word,
                exact: false,
            });
        }
    }

    None
}

fn derive_type_step(phrase: &str, index: usize) -> Result<Option<AgentPlanStep>, AgentError> {
    let value = extract_first_quoted(phrase).unwrap_or_else(|| infer_value(phrase));
    let field = extract_second_quoted(phrase).or_else(|| infer_field_name(phrase));

    if value.is_empty() {
        return Ok(None);
    }

    let locator = field
        .map(|name| {
            AgentLocator::Css(format!(
                "input[name='{}']",
                sanitize_selector_component(&name)
            ))
        })
        .unwrap_or_else(|| AgentLocator::Css("input".to_string()));

    let mut step = AgentPlanStep::new(
        step_id(index),
        "Type text",
        AgentTool {
            kind: AgentToolKind::TypeText {
                locator: locator.clone(),
                text: value.clone(),
                submit: should_submit(phrase),
            },
            wait: WaitMode::DomReady,
            timeout_ms: None,
        },
    )
    .with_detail(format!(
        "Type '{}' into {:?}",
        value,
        locator_description(&locator)
    ));

    step.validations.push(AgentValidation {
        description: "Field contains expected value".to_string(),
        condition: AgentWaitCondition::ElementVisible(locator.clone()),
    });

    Ok(Some(step))
}

fn derive_select_step(phrase: &str, index: usize) -> Result<Option<AgentPlanStep>, AgentError> {
    let option = extract_first_quoted(phrase).unwrap_or_default();
    if option.is_empty() {
        return Ok(None);
    }

    let field = extract_second_quoted(phrase).or_else(|| infer_field_name(phrase));
    let locator = field
        .map(|name| {
            AgentLocator::Css(format!(
                "select[name='{}']",
                sanitize_selector_component(&name)
            ))
        })
        .unwrap_or_else(|| AgentLocator::Css("select".to_string()));

    let mut step = AgentPlanStep::new(
        step_id(index),
        "Select option",
        AgentTool {
            kind: AgentToolKind::Select {
                locator: locator.clone(),
                value: option.clone(),
                method: Some("text".to_string()),
            },
            wait: WaitMode::DomReady,
            timeout_ms: None,
        },
    )
    .with_detail(format!(
        "Choose option '{}' from {:?}",
        option,
        locator_description(&locator)
    ));

    step.validations.push(AgentValidation {
        description: "Dropdown reflects selected value".to_string(),
        condition: AgentWaitCondition::ElementVisible(locator.clone()),
    });

    Ok(Some(step))
}

fn derive_scroll_step(phrase: &str, index: usize) -> Result<Option<AgentPlanStep>, AgentError> {
    let lower = phrase.to_lowercase();

    if lower.contains("top") {
        return Ok(Some(
            AgentPlanStep::new(
                step_id(index),
                "Scroll to top",
                AgentTool {
                    kind: AgentToolKind::Scroll {
                        target: AgentScrollTarget::Top,
                    },
                    wait: WaitMode::None,
                    timeout_ms: None,
                },
            )
            .with_detail("Scroll the page to the top"),
        ));
    }

    if lower.contains("bottom") {
        return Ok(Some(
            AgentPlanStep::new(
                step_id(index),
                "Scroll to bottom",
                AgentTool {
                    kind: AgentToolKind::Scroll {
                        target: AgentScrollTarget::Bottom,
                    },
                    wait: WaitMode::None,
                    timeout_ms: None,
                },
            )
            .with_detail("Scroll the page to the bottom"),
        ));
    }

    if let Some(delta) = capture_scroll_pixels(phrase) {
        return Ok(Some(build_scroll_pixels_step(index, delta)));
    }

    if lower.contains("down") {
        let delta = capture_scroll_pixels(phrase).unwrap_or(DEFAULT_SCROLL_PIXELS);
        return Ok(Some(build_scroll_pixels_step(index, delta.abs())));
    }

    if lower.contains("up") {
        let delta = capture_scroll_pixels(phrase).unwrap_or(DEFAULT_SCROLL_PIXELS);
        return Ok(Some(build_scroll_pixels_step(index, -(delta.abs()))));
    }

    Ok(None)
}

fn build_scroll_pixels_step(index: usize, delta: i32) -> AgentPlanStep {
    let direction = if delta >= 0 { "down" } else { "up" };
    AgentPlanStep::new(
        step_id(index),
        if delta >= 0 {
            "Scroll down"
        } else {
            "Scroll up"
        },
        AgentTool {
            kind: AgentToolKind::Scroll {
                target: AgentScrollTarget::Pixels(delta),
            },
            wait: WaitMode::None,
            timeout_ms: None,
        },
    )
    .with_detail(format!("Scroll {} pixels {}", delta.abs(), direction))
}

fn capture_wait_seconds(text: &str) -> Option<u64> {
    WAIT_SECONDS_REGEX
        .captures(text)
        .and_then(|capture| capture.name("secs"))
        .and_then(|m| m.as_str().parse::<u64>().ok())
}

fn extract_first_url(text: &str) -> Option<String> {
    URL_REGEX
        .find(text)
        .map(|m| m.as_str().trim_end_matches(['.', ',', ';']).to_string())
}

fn split_phrases(input: &str) -> Vec<String> {
    let mut parts = vec![input.to_string()];
    for sep in [" then ", " and then ", "->", ";", "."] {
        let mut next = Vec::new();
        for part in parts {
            for segment in part.split(sep) {
                let trimmed = segment.trim();
                if !trimmed.is_empty() {
                    next.push(trimmed.to_string());
                }
            }
        }
        parts = next;
    }
    parts
}

fn extract_first_quoted(text: &str) -> Option<String> {
    QUOTED_REGEX
        .captures(text)
        .and_then(|caps| caps.get(1).or_else(|| caps.get(2)))
        .map(|m| m.as_str().to_string())
}

fn extract_second_quoted(text: &str) -> Option<String> {
    let mut iter = QUOTED_REGEX.captures_iter(text);
    iter.next()?;
    iter.next()
        .and_then(|caps| caps.get(1).or_else(|| caps.get(2)))
        .map(|m| m.as_str().to_string())
}

fn infer_value(phrase: &str) -> String {
    if let Some(capture) = VALUE_WORD_REGEX.captures(phrase) {
        capture
            .name("value")
            .map(|m| m.as_str().trim().to_string())
            .unwrap_or_default()
    } else {
        String::new()
    }
}

fn infer_field_name(phrase: &str) -> Option<String> {
    if let Some(capture) = FIELD_WORD_REGEX.captures(phrase) {
        capture
            .name("field")
            .map(|m| {
                m.as_str()
                    .trim_matches(|c: char| !c.is_alphanumeric() && c != ' ')
            })
            .map(|s| s.trim().to_string())
    } else {
        None
    }
}

fn sanitize_selector_component(input: &str) -> String {
    input
        .chars()
        .filter(|ch| ch.is_alphanumeric() || *ch == '_' || *ch == '-')
        .collect::<String>()
        .to_lowercase()
}

fn capture_scroll_pixels(text: &str) -> Option<i32> {
    let normalized = text.to_lowercase();
    SCROLL_PIXELS_REGEX
        .captures(&normalized)
        .and_then(|caps| caps.name("value"))
        .and_then(|m| m.as_str().replace(',', "").parse::<i32>().ok())
        .map(|value| {
            if normalized.contains("up") && !normalized.contains("down") {
                -value.abs()
            } else {
                value.abs()
            }
        })
}

fn locator_description(locator: &AgentLocator) -> Cow<'static, str> {
    match locator {
        AgentLocator::Css(_) => Cow::Borrowed("a CSS selector"),
        AgentLocator::Aria { .. } => Cow::Borrowed("an ARIA role/name pair"),
        AgentLocator::Text { .. } => Cow::Borrowed("text content match"),
    }
}

fn should_submit(phrase: &str) -> bool {
    let lowered = phrase.to_lowercase();
    lowered.contains("submit")
        || lowered.contains("press enter")
        || lowered.contains("hit enter")
        || lowered.contains("press return")
}

fn default_risks(request: &AgentRequest) -> Vec<String> {
    let mut risks = Vec::new();
    if request.goal.to_lowercase().contains("login") {
        risks
            .push("Contains authentication instructions; confirm credential handling.".to_string());
    }
    if request.goal.to_lowercase().contains("payment") {
        risks.push("Potential payment flow; ensure approval before executing.".to_string());
    }
    if risks.is_empty() {
        risks.push("Standard automation risk; monitor for navigation drift.".to_string());
    }
    risks
}

fn vendor_context_snapshot(request: &AgentRequest) -> HashMap<String, Value> {
    let mut map = HashMap::new();
    map.insert(
        "conversation_turns".to_string(),
        Value::Number(JsonNumber::from(request.conversation.len() as u64)),
    );
    map.insert(
        "constraints".to_string(),
        Value::Array(
            request
                .constraints
                .iter()
                .map(|c| Value::String(c.clone()))
                .collect(),
        ),
    );
    map
}

static URL_REGEX: Lazy<Regex> = Lazy::new(|| Regex::new(r"https?://[^\s]+").expect("url regex"));
static QUOTED_REGEX: Lazy<Regex> =
    Lazy::new(|| Regex::new(r#""([^"]+)"|'([^']+)'"#).expect("quoted regex"));
static WAIT_SECONDS_REGEX: Lazy<Regex> = Lazy::new(|| {
    Regex::new(r"wait(?:\s+for)?\s+(?P<secs>\d+)(?:\s*)(?:seconds|secs|s)").expect("wait regex")
});
static CLICK_WORD_REGEX: Lazy<Regex> = Lazy::new(|| {
    Regex::new(r"click(?: on)?(?: the)? (?P<label>[a-zA-Z0-9 ]+)").expect("click regex")
});
static VALUE_WORD_REGEX: Lazy<Regex> = Lazy::new(|| {
    Regex::new(r"(?:type|enter|input) (?P<value>[a-zA-Z0-9@.\-_]+)").expect("value regex")
});
static FIELD_WORD_REGEX: Lazy<Regex> = Lazy::new(|| {
    Regex::new(r"(?:into|in|for) (?:the )?(?P<field>[a-zA-Z0-9 _-]+)(?: field)?")
        .expect("field regex")
});
static SCROLL_PIXELS_REGEX: Lazy<Regex> = Lazy::new(|| {
    Regex::new(
        r"scroll(?:\s+(?:up|down))?(?:\s+by)?\s+(?P<value>[-+]?[0-9]{1,4})(?:\s*(?:px|pixels)?)",
    )
    .expect("scroll pixels regex")
});

const DEFAULT_SCROLL_PIXELS: i32 = 600;
