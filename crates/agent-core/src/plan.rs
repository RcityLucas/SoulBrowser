use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use soulbrowser_core_types::TaskId;
use std::collections::HashMap;

/// Metadata describing the generated plan and provenance information.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct AgentPlanMeta {
    /// Short rationale generated by the planner summarizing approach.
    pub rationale: Vec<String>,
    /// Indicators describing confidence or risk per plan.
    pub risk_assessment: Vec<String>,
    /// Optional raw prompt or planner specific payload.
    pub vendor_context: HashMap<String, serde_json::Value>,
    /// Human-readable overlays explaining auto repairs or plan notes.
    #[serde(default)]
    pub overlays: Vec<serde_json::Value>,
}

/// A high-level plan generated by the agent planner.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentPlan {
    /// Task identifier propagated from the request.
    pub task_id: TaskId,
    /// Human readable label for the plan.
    pub title: String,
    /// Longer description covering scope or assumptions.
    pub description: String,
    /// Ordered execution steps.
    pub steps: Vec<AgentPlanStep>,
    /// Timestamp when plan was produced.
    pub created_at: DateTime<Utc>,
    /// Plan metadata and rationale.
    #[serde(default)]
    pub meta: AgentPlanMeta,
}

impl AgentPlan {
    pub fn new(task_id: TaskId, title: impl Into<String>) -> Self {
        Self {
            task_id,
            title: title.into(),
            description: String::new(),
            steps: Vec::new(),
            created_at: Utc::now(),
            meta: AgentPlanMeta::default(),
        }
    }

    pub fn with_description(mut self, description: impl Into<String>) -> Self {
        self.description = description.into();
        self
    }

    pub fn push_step(&mut self, step: AgentPlanStep) {
        self.steps.push(step);
    }
}

/// A single step in an agent plan.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentPlanStep {
    /// Identifier unique within the plan.
    pub id: String,
    /// Short action label.
    pub title: String,
    /// Detailed explanation of intent and expected outcome.
    pub detail: String,
    /// Tool invocation kind.
    pub tool: AgentTool,
    /// Optional validation rules to apply after tool completes.
    #[serde(default)]
    pub validations: Vec<AgentValidation>,
    /// Whether user approval is required before executing this step.
    #[serde(default)]
    pub requires_approval: bool,
    /// Free-form metadata for downstream components.
    #[serde(default)]
    pub metadata: HashMap<String, serde_json::Value>,
}

impl AgentPlanStep {
    pub fn new(id: impl Into<String>, title: impl Into<String>, tool: AgentTool) -> Self {
        Self {
            id: id.into(),
            title: title.into(),
            detail: String::new(),
            tool,
            validations: Vec::new(),
            requires_approval: false,
            metadata: HashMap::new(),
        }
    }

    pub fn with_detail(mut self, detail: impl Into<String>) -> Self {
        self.detail = detail.into();
        self
    }

    pub fn with_validation(mut self, validation: AgentValidation) -> Self {
        self.validations.push(validation);
        self
    }
}

/// Supported wait tiers that can be mapped onto action primitives.
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
pub enum WaitMode {
    None,
    DomReady,
    Idle,
}

impl Default for WaitMode {
    fn default() -> Self {
        WaitMode::DomReady
    }
}

/// Locator abstraction for referencing DOM targets.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AgentLocator {
    Css(String),
    Aria { role: String, name: String },
    Text { content: String, exact: bool },
}

/// Condition monitored for waits or validations.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AgentWaitCondition {
    ElementVisible(AgentLocator),
    ElementHidden(AgentLocator),
    UrlMatches(String),
    UrlEquals(String),
    TitleMatches(String),
    NetworkIdle(u64),
    Duration(u64),
}

/// Validation to perform after executing a step.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentValidation {
    pub description: String,
    pub condition: AgentWaitCondition,
}

/// Tool invocation specification with optional wait tuning.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentTool {
    pub kind: AgentToolKind,
    #[serde(default)]
    pub wait: WaitMode,
    /// Optional timeout in milliseconds for the tool invocation.
    #[serde(default)]
    pub timeout_ms: Option<u64>,
}

/// Supported tool kinds for the initial L8 MVP.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AgentToolKind {
    Navigate {
        url: String,
    },
    Click {
        locator: AgentLocator,
    },
    TypeText {
        locator: AgentLocator,
        text: String,
        submit: bool,
    },
    Select {
        locator: AgentLocator,
        value: String,
        method: Option<String>,
    },
    Scroll {
        target: AgentScrollTarget,
    },
    Wait {
        condition: AgentWaitCondition,
    },
    Custom {
        name: String,
        payload: serde_json::Value,
    },
    /// Agent signals task completion (for agent loop mode).
    /// The LLM uses this to indicate the task is finished.
    Done {
        /// Whether the task was completed successfully.
        success: bool,
        /// Completion message, result summary, or extracted content.
        text: String,
    },
}

/// Scroll targets exposed to the planner.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AgentScrollTarget {
    Top,
    Bottom,
    Selector(AgentLocator),
    Pixels(i32),
}
