use std::fs;
use std::path::PathBuf;

use anyhow::{bail, Context, Result};
use clap::Parser;

/// Create a parser module + schema stub.
#[derive(Parser, Debug)]
#[command(
    name = "parser_scaffold",
    about = "Generate parser + schema boilerplate"
)]
struct Args {
    /// Human readable name (e.g. "twitter-feed")
    name: String,
    /// Optional schema id override
    #[arg(long, value_name = "ID")]
    schema_id: Option<String>,
    /// Optional schema title override
    #[arg(long, value_name = "TITLE")]
    title: Option<String>,
    /// Optional schema description override
    #[arg(long, value_name = "TEXT")]
    description: Option<String>,
    /// Overwrite existing files
    #[arg(long)]
    force: bool,
}

fn main() -> Result<()> {
    let args = Args::parse();
    run(args)
}

fn run(args: Args) -> Result<()> {
    let module = slugify(&args.name);
    if module.is_empty() {
        bail!("parser name must contain at least one alphanumeric character");
    }
    let schema_id = args.schema_id.unwrap_or_else(|| format!("{}_v1", module));
    let parser_fn = format!("parse_{}", module);
    let schema_title = args
        .title
        .unwrap_or_else(|| format!("{} schema", title_case(&module)));
    let schema_description = args.description.unwrap_or_else(|| {
        format!(
            "Structured payload generated by the {} parser.",
            module.replace('_', " ")
        )
    });

    write_parser_module(&module, &parser_fn, &schema_id, args.force)?;
    update_mod_rs(&module, &parser_fn)?;
    write_schema_stub(&schema_id, &schema_title, &schema_description, args.force)?;
    write_deliver_sample(&schema_id, &schema_title, &module, args.force)?;

    println!("✅ Created parser template: src/parsers/{}.rs", module);
    println!("✅ Schema stub: docs/reference/schemas/{}.json", schema_id);
    println!(
        "✅ Deliver sample: docs/reference/schemas/{}_deliver.md",
        schema_id
    );
    println!("➡ Next steps:\n  • Implement {}()\n  • Update docs/reference/schema_catalog.md\n  • Wire planner/executor handling (data.parse.{})\n  • Add tests + deliver step",
        parser_fn,
        module.replace('_', ".")
    );
    Ok(())
}

fn write_parser_module(module: &str, parser_fn: &str, schema: &str, force: bool) -> Result<()> {
    let path = PathBuf::from(format!("src/parsers/{}.rs", module));
    if path.exists() && !force {
        bail!(
            "parser module '{}' already exists (use --force to overwrite)",
            path.display()
        );
    }
    let template = format!(
        r#"use anyhow::{{anyhow, Result}};
use serde_json::Value;
use soulbrowser_kernel::parsers::helpers::extract_observation_metadata;

const SCHEMA_ID: &str = "{schema}";

/// Parse observation output into the `{schema}` schema.
pub fn {parser_fn}(observation: &Value) -> Result<Value> {{
    let metadata = extract_observation_metadata(observation);
    let _ = metadata;
    Err(anyhow!("parser '{{}}' is not implemented yet", SCHEMA_ID))
}}

#[cfg(test)]
mod tests {{
    use super::*;
    use serde_json::json;

    #[test]
    fn parser_is_stubbed() {{
        let obs = json!({{"url": "https://example.com"}});
        let err = {parser_fn}(&obs).expect_err("stub should error");
        assert!(err.to_string().contains("not implemented"));
    }}
}}
"#
    );
    fs::write(&path, template)
        .with_context(|| format!("write parser module '{}'", path.display()))?;
    Ok(())
}

fn update_mod_rs(module: &str, parser_fn: &str) -> Result<()> {
    let path = PathBuf::from("src/parsers/mod.rs");
    let mut contents = fs::read_to_string(&path).context("read src/parsers/mod.rs")?;
    let mod_line = format!("pub mod {};", module);
    if !contents.contains(&mod_line) {
        if !contents.ends_with('\n') {
            contents.push('\n');
        }
        contents.push_str(&format!("{}\n", mod_line));
    }
    let use_line = format!("pub use {}::{};", module, parser_fn);
    if !contents.contains(&use_line) {
        contents.push_str(&format!("{}\n", use_line));
    }
    fs::write(&path, contents).with_context(|| format!("update {}", path.display()))?;
    Ok(())
}

fn write_schema_stub(id: &str, title: &str, description: &str, force: bool) -> Result<()> {
    let path = PathBuf::from(format!("docs/reference/schemas/{}.json", id));
    if path.exists() && !force {
        bail!(
            "schema file '{}' already exists (use --force to overwrite)",
            path.display()
        );
    }
    if let Some(parent) = path.parent() {
        fs::create_dir_all(parent).context("ensure schema directory")?;
    }
    let schema = format!(
        r#"{{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "{title}",
  "description": "{description}",
  "type": "object",
  "properties": {{
    "schema": {{ "type": "string", "const": "{id}" }},
    "items": {{
      "type": "array",
      "description": "TODO: describe collection",
      "items": {{
        "type": "object",
        "description": "TODO: describe item shape"
      }}
    }}
  }},
  "required": ["schema", "items"],
  "additionalProperties": false
}}
"#
    );
    fs::write(&path, schema).with_context(|| format!("write schema stub {}", path.display()))?;
    Ok(())
}

fn write_deliver_sample(id: &str, title: &str, module: &str, force: bool) -> Result<()> {
    let path = PathBuf::from(format!("docs/reference/schemas/{}_deliver.md", id));
    if path.exists() && !force {
        bail!(
            "deliver sample '{}' already exists (use --force to overwrite)",
            path.display()
        );
    }
    if let Some(parent) = path.parent() {
        fs::create_dir_all(parent).context("ensure schema directory")?;
    }
    let artifact_label = format!("structured.{}", id);
    let parse_step_hint = format!("parse-{}", module.replace('_', "-"));
    let screenshot_hint = format!("artifacts/{}-screenshot.png", module.replace('_', "-"));
    let contents = format!(
        r#"# {title} delivery example

```json
{{
  "id": "{parse_step_hint}-deliver",
  "tool": "data.deliver.structured",
  "payload": {{
    "schema": "{id}",
    "artifact_label": "{artifact_label}",
    "filename": "{id}.json",
    "source_step_id": "{parse_step_hint}",
    "screenshot_path": "{screenshot_hint}"
  }}
}}
```

- Replace `source_step_id` with the actual parse step id from your plan (`{parse_step_hint}` is a suggested default).
- Update `artifact_label` / filename if you need different naming conventions.
- Drop `screenshot_path` when no capture is required (deliver will still attach the JSON artifact).

"#
    );
    fs::write(&path, contents)
        .with_context(|| format!("write deliver sample {}", path.display()))?;
    Ok(())
}

fn slugify(input: &str) -> String {
    let mut slug = String::new();
    for ch in input.chars() {
        if ch.is_ascii_alphanumeric() {
            slug.push(ch.to_ascii_lowercase());
        } else if !slug.ends_with('_') {
            slug.push('_');
        }
    }
    slug.trim_matches('_').to_string()
}

fn title_case(slug: &str) -> String {
    slug.split('_')
        .filter(|part| !part.is_empty())
        .map(|part| {
            let mut chars = part.chars();
            match chars.next() {
                Some(first) => format!("{}{}", first.to_ascii_uppercase(), chars.as_str()),
                None => String::new(),
            }
        })
        .collect::<Vec<_>>()
        .join(" ")
}
