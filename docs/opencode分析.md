- **总体印象（简要）**

  - 代码量级极大，模块化程度高，但入口与核心职责在若干地方高度耦合，维护成本较高。
  - 主要链路（CLI <-> Kernel <-> 感知/执行/网关）在文档与实现上基本一致，但某些设计在多租户/动态策略场景下的健壮性不足。
  - 安全、配置、缓存、以及对外接口的默认行为是重点需要明确化的地方。

  ------

  **存在的设计性问题与风险点**

  1. 过度“单体化”的 AppContext/缓存设计

  - 问题点：AppContext 的创建包含 Storage/Auth/ToolManager/PolicyCenter/Registry/Scheduler 等大量职责，且存在一个全局的 CONTEXT_CACHE（tenant/storage/policy_hash 作为键）。这容易导致缓存失效时难以维护，且多租户场景下共享状态的边界不清晰。
  - 潜在后果：策略变更、存储路径变更、租户切换时可能仍然复用过期上下文，导致不可预测行为。

  1. 缓存失效与策略更新的“隐式”刷新

  - 问题点：ContextKey 使用 policy_paths 的哈希来区分上下文，但如果策略文件在运行时被修改却没有及时刷新缓存，可能继续使用旧策略。
  - 潜在后果：策略变更不生效，或者产生难以追踪的行为差异。

  1. 安全默认值与认证策略的“隐式禁用”

  - 问题点：Serve 的认证策略在没有 tokens 的情况下会警告并最终禁用认证，且缺省下可能暴露接口。
  - 潜在后果：生产环境若未显式配置强认证，端口暴露带来安全风险。

  1. 错误处理与跨 crate 的一致性

  - 问题点：大量使用 anyhow，部分函数返回的是真正的错误类型（SoulBrowserError），混用可能导致错误链追踪困难。
  - 潜在后果：错误分发、日志中的上下文不统一，诊断成本增高。

  1. 多 Surfaces 共用同一 Kernel 的边界与生命周期

  - 问题点：CLI 的 serve/gateway/ perception 等 surface 复用同一个 Kernel 实例与状态，缺乏清晰的生命周期隔离。
  - 潜在后果：同一进程内的并发 Surface 之间可能出现资源竞争、状态污染或清理困难。

  1. 测试覆盖与对外依赖的松耦合度

  - 问题点：感知、浏览器驱动、网关等核心部分对 Chrome/CDP 等外部依赖强敏感，测试在没有完整 Chrome/浏览器环境时可能困难。
  - 潜在后果：CI 及本地快速回归的可用性不足，变更难以验证。

  1. 配置与默认行为的可预测性

  - 问题点：当没有显式配置时默认走 defaults，且 YAML/ENV 的组合可能产生难以预测的行为。
  - 潜在后果：新开发者容易误解默认行为，导致生产环境不一致。

  1. 插件/网关实现的成熟度与路线不清晰

  - 问题点：文档提及的 gateway、l7-adapter、plugin 等模块有未实现或待增强的部分（TODO、stub），这可能成为集成风险点。
  - 潜在后果：短期内很难对外暴露稳定的接口或保障端到端的治理。

  ------

  **改进方向（可落地的策略性方向）**

  A. 清晰化租户边界与缓存策略

  - 做法要点：
    - 将 ContextCache 的键改为更可控的版本，确保策略变更时能显式失效缓存（如引入策略版本号/时间戳）。
    - 对每个租户设计严格的沙箱边界，尽量避免跨租户共享全局状态，必要时引入租户隔离的内存/存储上下文。
    - 提供显式的“刷新上下文”操作，或在策略文件检测到变更时自动触发缓存失效。
  - 期望效果：降低因为策略/存储变更导致的不可预测行为。

  B. 将认证策略提升为默认的安全基线

  - 做法要点：
    - 将“无 tokens 时禁用认证”改为“强制需要至少一个 token/白名单”，作为默认的安全基线；将可选项公开为显式开关。
    - 允许在 config.yaml 明确声明严格认证开关和默认行为，避免隐式禁用。
    - 增加默认告警与拒绝服务策略（例如在未配置认证时拒绝外部请求，至少在生产环境中如此）。
  - 期望效果：提升默认安全性，减少生产环境的误配置风险。

  C. 统一的错误类型与错误传播规范

  - 做法要点：
    - 尽量统一使用一个错误类型（如 SoulBrowserError 封装各种场景），在外部暴露时提供足够的上下文信息。
    - 对公有 API 调用、网关、CLI 边界清晰地传递错误链，避免“内部错误暴露给客户端”的情况。
  - 期望效果：诊断与日志更一致，错误处理更易维护。

  D. 模块边界与职责分离的分步重构

  - 做法要点：
    - 将 Kernel 的“核心运行时”和“Surface 接口”逐步解耦，例如通过一个更明确的 RuntimeFacade 抽象来暴露服务，而不是直接暴露内部 AppContext。
    - 将 AppContext 的核心职责拆分成更小的、职责单一的组件（Storage/Auth/ToolManager/PolicyCenter/Registry/... 的职责分离，提供清晰的 API 边界）。
  - 期望效果：降低维护成本、提高测试性与可替换性。

  E. 加强对外依赖的测试友好性

  - 做法要点：
    - 为感知、浏览器驱动（CDP）等建立更强的 mocked/模拟测试层，提供“ Ephemeral/Shared”两种路径的可控替换。
    - 引入集成测试钩子，允许在 CI 中以最小依赖运行草拟的端到端流程（不强制打开真实 Chrome）。
  - 期望效果：开发与 CI 反馈更快，回归更稳健。

  F. 配置驱动的行为可预测性与文档化

  - 做法要点：
    - 引入一个最小可用配置模板，所有缺省行为要有清晰注释说明，并提供快速校验命令（如 config --lint 等）。
    - 保证 YAML 与 ENV 的覆盖顺序有明确规则，避免“第二次覆盖”意外生效。
  - 期望效果：新成员更容易上手，减少部署时的隐性差异。

  G. 收藏性与文档同步

  - 做法要点：
    - 将 docs/module_deep_dive.md 作为活跃设计文档，定期生成更新的系统图、接口契约（CLI -> Kernel -> Surface）的序列图。
    - 给出一个“设计变更日志”区域，凡是重大设计变更必须在文档中同步。
  - 期望效果：团队对架构变更保持一致理解，减少知识断层。

  ------

  **短期可落地的3–5项改动（建议优先级）**

  1. 安全基线与 auth 行为明确化
     - 将无 token 时的认证禁用改为强制/明确需配置，更新 docs 与默认配置。
  2. 缓存失效策略与策略版本化
     - 为 AppContext 缓存引入策略版本号，策略变更时显式触发缓存失效。
  3. 错误类型统一与封装
     - 引入 SoulBrowserError 统一错误族，统一从各处向调用方暴露的错误类型。
  4. 明确租户边界与分离
     - 将租户相关的全局状态分离成明确边界，避免跨租户状态污染，必要时引入租户作用域的存储/会话。
  5. 提供轻量级的 Mock 测试路径
     - 为感知/CDP 相关模块引入 Mock 饱和路径，降低 CI 对 Chrome 的依赖，提升回归能力。